el[Node2 == el[random.edge, Node2], to.infected := TRUE]
# update infection informagtion in infected_data
infected_data[Nodes == el[random.edge, Node2], infected := TRUE]
}
}
}
length(which(infected_data$infected))/length(infected_data$infected)
t <- 1
# update infected list
if(t == 1){
infections[[t]] <- infected
} else if(t == runs + 1){
hundred.thousands <- hundred.thousands + 1
inf <- infections[[t-1]]
infections <- vector(length = 1, mode = "list")
infections[[1]] <- inf
t <- 1
} else {
infections[[t]] <- infections[[t-1]]
}
# select random edge
random.edge <- sample(nrow(el), size = 1)
el[random.edge]
t <- 2
# update infected list
if(t == 1){
infections[[t]] <- infected
} else if(t == runs + 1){
hundred.thousands <- hundred.thousands + 1
inf <- infections[[t-1]]
infections <- vector(length = 1, mode = "list")
infections[[1]] <- inf
t <- 1
} else {
infections[[t]] <- infections[[t-1]]
}
# select random edge
random.edge <- sample(nrow(el), size = 1)
el[random.edge]
# determine whether one of the edge's nodes are susceptible
if (el[random.edge, from.infected] != el[random.edge, to.infected]){
# get Node 1 infection information from infected_data table
node1 <- which(el[random.edge, Node1] == infected_data[, Nodes])
# get Node 2 infection information from infected_data table
node2 <- which(el[random.edge, Node2] == infected_data[, Nodes])
# detect susceptible node
who.susceptible <- c(node1, node2)[!c(infections[[t]][node1],
infections[[t]][node2])]
# sample whether susceptible node will be infected
infections[[t]][who.susceptible] <- sample(
c(T, F),
size = 1,
prob = c(p.infection, 1 - p.infection)
)
# if susceptible node gets infected ...
if(infections[[t]][who.susceptible] == TRUE){
# AND if newly infected node is Node1 ...
if(which(!el[random.edge, c(from.infected, to.infected)]) == 1){
# update infection information in el
el[Node1 == el[random.edge, Node1], from.infected := TRUE]
el[Node2 == el[random.edge, Node1], to.infected := TRUE]
# update infection informagtion in infected_data
infected_data[Nodes == el[random.edge, Node1], infected := TRUE]
}
# AND if newly infected node is Node2
else if (which(!el[random.edge, c(from.infected, to.infected)]) == 2){
# update infection information in el
el[Node1 == el[random.edge, Node2], from.infected := TRUE]
el[Node2 == el[random.edge, Node2], to.infected := TRUE]
# update infection informagtion in infected_data
infected_data[Nodes == el[random.edge, Node2], infected := TRUE]
}
}
}
el[random.edge]
length(which(infected_data$infected))/length(infected_data$infected)
# save required number of iterations needed to achieve 70% of nodes infected
if(length(which(infected_data$infected))/length(infected_data$infected) > 0.7){
if(j == 1){
write.table(data.table(Name = file, Domain = domain, Nodes = n.people, Iterations_1 = length(infections)),
file = sprintf("output/diffusion/diffusion_results_%s2.csv", n), sep = ",", row.names = F,
col.names = T)
} else {
write.table(data.table(file, domain, n.people, length(infections)),
file = sprintf("output/diffusion/diffusion_results_%s2.csv", n), sep = ",", row.names = F,
append = T, col.names = F)
}
break
}
length(which(infected_data$infected))/length(infected_data$infected) > 0.7
j == 1
(length(infections) +
hundred.thousands)
hundred.thousands*runs
write.table(data.table(Name = file, Domain = domain, Nodes = n.people, Iterations_1 = (length(infections) +
(hundred.thousands*runs))),
file = sprintf("output/diffusion/diffusion_results_%s2.csv", n), sep = ",", row.names = F,
col.names = T)
(length(infections) +
(hundred.thousands*runs))
data.table(Name = file, Domain = domain, Nodes = n.people, Iterations_1 = (length(infections) +
(hundred.thousands*runs))
data.table(Name = file, Domain = domain, Nodes = n.people, Iterations_1 = (length(infections) +
(hundred.thousands*runs)))
n <- 1
# save required number of iterations needed to achieve 70% of nodes infected
if(length(which(infected_data$infected))/length(infected_data$infected) > 0.7){
if(j == 1){
write.table(data.table(Name = file, Domain = domain, Nodes = n.people, Iterations_1 = (length(infections) +
(hundred.thousands*runs))),
file = sprintf("output/diffusion/diffusion_results_%s2.csv", n), sep = ",", row.names = F,
col.names = T)
} else {
write.table(data.table(file, domain, n.people, (length(infections) + hundred.thousands)),
file = sprintf("output/diffusion/diffusion_results_%s2.csv", n), sep = ",", row.names = F,
append = T, col.names = F)
}
break
}
(length(infections) +
(hundred.thousands*runs))
i <- 1
while(i <= 1:10){
n <- 1 + i
print(n)
}
warninga()
warnings()
i <- 1
while(i < 1:10){
n <- 1 + i
print(n)
}
i <- 1
while(i < 10){
n <- 1 + i
print(n)
}
i <- 1
while(i < 10){
i <- 1 + i
print(i)
}
### parameters
p.infection <- 1 # probability of infection
pct.starting.infected <- 0.5 # percentage of nodes that start infected
runs <- 5 # number of iterations
# load in master data
master_data <- fread("output/undirected/master_measures_2.csv")[, c("Name", "NetworkDomain")]
list.of.packages <- c("data.table", "igraph", "statnet", "tidyverse", "magrittr", "dplyr")
sapply(list.of.packages, library, character.only = TRUE)
rm(list.of.packages)
# load in master data
master_data <- fread("output/undirected/master_measures_2.csv")[, c("Name", "NetworkDomain")]
master[282]
master[283]
j <- 1
# load in network
file <- as.character(master_data[j, Name])
domain <- as.character(master_data[j, NetworkDomain])
nw <- fread(sprintf("data/all_data/%s.csv", file))
g <- graph_from_data_frame(nw, directed = F)
j <- 283
# load in network
file <- as.character(master_data[j, Name])
domain <- as.character(master_data[j, NetworkDomain])
nw <- fread(sprintf("data/all_data/%s.csv", file))
j <- 282
# load in network
file <- as.character(master_data[j, Name])
domain <- as.character(master_data[j, NetworkDomain])
nw <- fread(sprintf("data/all_data/%s.csv", file))
g <- graph_from_data_frame(nw, directed = F)
# create list to store different iterations
infections <- vector(length = 1, mode = "list")
# get number of nodes
n.people <- gorder(g)
# create initial infection information
infected <- sample(
x = c(T, F),
size = n.people,
replace = T,
prob = c(pct.starting.infected, 1 - pct.starting.infected)
)
View(infections)
# ensure at least one node is infected
if(length(which(infected)) == 0){
infect <- sample(length(infected), size = 1)
infected[infect] <- TRUE
}
# ordering nodes
V_order <- sort(as.integer(V(g)$name))
# create data frame of infection indices for each node
infected_data <- data.table(Nodes = V_order, infected = infected)
length(which(infected_data$infected))
# add infection index to each edge pair
from.list <- c()
to.list <- c()
for(i in 1:nrow(nw)){
node1 <- which(nw[i, Node1] == infected_data$Nodes)
from.inf <- infected_data[node1, infected]
from.list <- combine(from.list, from.inf)
node2 <- which(nw[i, Node2] == infected_data$Nodes)
to.inf <- infected_data[node2, infected]
to.list <- combine(to.list, to.inf)
}
# install packages
list.of.packages <- c("data.table", "corrplot", "ggplot2", "dplyr", "gridExtra")
sapply(list.of.packages, library, character.only = TRUE)
rm(list.of.packages)
#
measures <- fread("output/undirected/master_measures_2.csv")
# Degree Distribution
summary(measures$DegreeDistribution)
ggplot(measures, aes(x = DegreeDistribution, fill = NetworkDomain)) + geom_histogram() +
facet_grid(NetworkDomain ~ . ) + labs(y = "Count")
ggplot(measures, aes(x = DegreeDistribution, fill = NetworkDomain)) + geom_histogram(stat = count) +
facet_grid(NetworkDomain ~ . ) + labs(y = "Count")
ggplot(measures, aes(x = DegreeDistribution, fill = NetworkDomain)) + geom_histogram(stat = "count") +
facet_grid(NetworkDomain ~ . ) + labs(y = "Count")
?geom_histogram()
ggplot(measures, aes(x = DegreeDistribution, fill = NetworkDomain)) + geom_freqpoly() +
facet_grid(NetworkDomain ~ . ) + labs(y = "Count")
ggplot(measures, aes(x = DegreeDistribution, fill = NetworkDomain)) + stat_bin() +
facet_grid(NetworkDomain ~ . ) + labs(y = "Count")
ggplot(measures, aes(x = DegreeDistribution, fill = NetworkDomain)) + stat_bin()
# Degree Distribution
summary(measures$DegreeDistribution)
ggplot(measures[DegreeDistribution < 0.05], aes(x = DegreeDistribution, fill = NetworkDomain)) + geom_histogram()
ggplot(measures[DegreeDistribution < 0.03], aes(x = DegreeDistribution, fill = NetworkDomain)) + geom_histogram()
View(measures)
# Average Degree
summary(measures$AverageDegree)
ggplot(measures, aes(x = AverageDegree, fill = NetworkDomain)) + geom_histogram() +
facet_grid(NetworkDomain ~ . ) + labs(y = "Count")
ggplot(measures, aes(x = AverageDegree, fill = NetworkDomain)) + geom_histogram()
ggplot(measures[AverageDegree < 20], aes(x = AverageDegree, fill = NetworkDomain)) + geom_histogram()
ggplot(measures[AverageDegree < 500], aes(x = AverageDegree, fill = NetworkDomain)) + geom_histogram()
ggplot(measures[AverageDegree < 200], aes(x = AverageDegree, fill = NetworkDomain)) + geom_histogram()
ggplot(measures[AverageDegree < 150], aes(x = AverageDegree, fill = NetworkDomain)) + geom_histogram()
library(readr)
bitcoin <- read_csv("data/all_data/bitcoin.csv")
View(bitcoin)
library(igraph)
g <- graph_from_data_frame(bitcoin, directed = F)
degree_distribution(g)
?degree_distribution(g)
plot(g)
d <- degree_distribution(g)
ggplot(d) + geom_histogram()
hist(d)
degree(g)
mean(degree(g))
ggplot(measures[AverageDegree < 150], aes(x = AverageDegree, fill = NetworkDomain)) + geom_histogram()
ggplot(measures[AverageDegree < 130], aes(x = AverageDegree, fill = NetworkDomain)) + geom_histogram()
ggplot(measures[AverageDegree < 80], aes(x = AverageDegree, fill = NetworkDomain)) + geom_histogram()
degree(g)
var(degree(g))
hist(degree(g))
max(degree(g))
min(degree(g))
hist(degree(g)<200)
degree(g)<200
hist(which(degree(g)<200))
hist((degree(g)))
g <- fread("output/diffusion/diffusion_results_1.csv")
m <- fread("output/undirected/master_measures_2.csv")
m[Name %in% g$Name]
mm <- data.table(m[Name %in% g$Name], Iterations = g$Iterations,Nodes = g$Nodes)
mm$ratio <- mm$Nodes/mm$Iterations
fit <- lm(data = mm, Iterations ~ AverageDegree + AveragePathLength + AverageTransitivity + Closeness + DegreeAssortativity +
DegreeDistribution + Density + EigenvectorCentrality + GlobalTransitivity)
View(m)
View(mm)
ggplot(mm, aes(x = number_edges, y = Iterations)) + geom_point()
ggplot(mm, aes(x = number_edges, y = Nodes)) + geom_point()
ggplot(mm, aes(x = number_edges, y = Iterations)) + geom_point()
ggplot(mm, aes(x = number_edges, y = Nodes)) + geom_point()
ggplot(mm, aes(x = number_edges, y = Iterations, color = NetworkDomain)) + geom_point()
ggplot(mm[number_edges < 25000], aes(x = number_edges, y = Iterations, color = NetworkDomain)) + geom_point()
ggplot(mm[number_edges < 10000], aes(x = number_edges, y = Iterations, color = NetworkDomain)) + geom_point()
ggplot(mm[number_edges < 2000], aes(x = number_edges, y = Iterations, color = NetworkDomain)) + geom_point()
?degree_distribution
var(degree(g))
bitcoin <- read_csv("data/all_data/bitcoin.csv")
g <- graph_from_data_frame(bitcoin, directed = F)
var(degree(g))
sqrt(var(degree(g)))
var(degree(g))
var(degree.distribution(g))
View(mm)
mm$var <- var(mm$AverageDegree * mm$number_edges)
ggplot(mm, aes(x = var)) + geom_histogram()
mm$AverageDegree * mm$number_edges
mm$var <- mm$AverageDegree * mm$number_edges
mm$v <- var(mm$var)
mm$var <- mm$AverageDegree * mm$Nodes
mm$v <- var(mm$var)
var(degree(g))
View(m)
library(readr)
X7th_graders <- read_csv("data/all_data/7th_graders.csv")
View(X7th_graders)
7th_graders <- read_csv("data/all_data/7th_graders.csv")
th_graders <- read_csv("data/all_data/7th_graders.csv")
nodes <- c(th_graders$Node1, th_graders$Node2)
unique(nodes)
nw <- read_csv("data/all_data/amazon_ratings.csv")
nw <- read_csv("data/all_data/aids_blogs_/2005).csv")
nw <- read_csv("data/all_data/aids_blogs_/(2005).csv")
nw <- read_csv("data/all_data/aids_blogs_(2005).csv")
nw <- read_csv("data/all_data/anybeat.csv")
library(igraph)
g <- graph_from_data_frame(nw, directed = F)
V(g)
V(g)$node
V(g)$nodes
gorder(g)
s <- c(nw$Node1, nw$Node2)
unique(nodes)
s <- c(nw$Node1, nw$Node2)
nodes <- c(nw$Node1, nw$Node2)
unique(nodes)
length(unique(nodes))
gorder(g)
unique(nodes)
nodes <- unique(c(nw$Node1, nw$Node2))
nodes
sort(as.integer(nodes))
nodes
nodes
V_order <- sort(as.integer(nodes))
nodes
sort(as.integer(nodes))
length(unique(nodes))
nodes
nodes
sort(as.integer(nodes))
data.frame(nodes, V_order)
nodes
d <- data.frame(nodes, V_order)
View(g)
View(d)
nw <- read_csv("data/all_data/amail_eu_all.csv")
master_data =
fread("output/undirected/master_measures_2.csv")[, c("Name", "NetworkDomain", "number_edges")]
library(data.table)
master_data =
fread("output/undirected/master_measures_2.csv")[, c("Name", "NetworkDomain", "number_edges")]
View(master_data)
#' Simulate diffusion on network
#'
#' @param j network index (corresponds to 'Name' column in master_data)
#' @param p.infection probability of infection
#' @param pct.starting.infected percentage of nodes starting infected
#' @param n number of repetitions of diffusion
#' @return number of infection iterations for 70% of nodes infected
#' @export
#' @import data.table, igraph, dplyr
simulate.diffusion <- function(j, p.infection, pct.starting.infected, n, threshold, runs = 10000, master_data =
fread("output/undirected/master_measures_2.csv")[, c("Name", "NetworkDomain", "number_edges")]){
# load in network
file <- as.character(master_data[j, Name])
domain <- as.character(master_data[j, NetworkDomain])
edges <- master_data[j, number_edges]
el <- fread(sprintf("data/all_data/%s.csv", file))
# get number of nodes
nodes <- unique(c(el$Node1, el$Node2))
n.people <- length(nodes)
# create initial infection information
infected <- sample(
x = c(T, F),
size = n.people,
replace = T,
prob = c(pct.starting.infected, 1 - pct.starting.infected)
)
# ensure at least one node is infected
if(length(which(infected)) == 0){
infect <- sample(length(infected), size = 1)
infected[infect] <- TRUE
}
# ordering nodes
V_order <- sort(as.integer(nodes))
# create data frame of infection indices for each node
infected_data <- data.table(Nodes = V_order, infected = infected)
print(length(which(infected_data$infected))/length(infected_data$infected))
# remove some variables
rm(V_order)
ten.thousands <- 0
t <- 1
while(t < (runs+2)){
# select random edge
random.edge <- sample(nrow(el), size = 1)
el[random.edge]
c(infected_data[which(el[random.edge, Node1] == infected_data$Nodes), ],
infected_data[which(el[random.edge, Node2] == infected_data$Nodes), ])
# determine whether one of the edge's nodes are susceptible
if (infected_data[which(el[random.edge, Node1] == infected_data$Nodes), infected] !=
infected_data[which(el[random.edge, Node2] == infected_data$Nodes), infected]){
# detect susceptible node
who.susceptible <-  c(el[random.edge, Node1],el[random.edge, Node2])[!c(infected_data[el[random.edge, Node1] == infected_data$Nodes, infected],
infected_data[el[random.edge, Node2] == infected_data$Nodes, infected])]
# detect susceptible node
infected_data[who.susceptible == Nodes, infected := sample(
c(T, F),
size = 1,
prob = c(p.infection, 1 - p.infection)
)]
}
print(length(which(infected_data$infected))/length(infected_data$infected))
# save required number of iterations needed to achieve 70% of nodes infected
if(length(which(infected_data$infected))/length(infected_data$infected) >= threshold){
if(j == 1){
write.table(data.table(Name = file, Domain = domain, Nodes = n.people, Edges = edges,
Iterations_1 = (t + (ten.thousands*runs))),
file = sprintf("output/diffusion/diffusion_results_%s_v.2.0.csv", n), sep = ",", row.names = F,
col.names = T)
} else {
write.table(data.table(file, domain, n.people, edges, (t + (ten.thousands*runs))),
file = sprintf("output/diffusion/diffusion_results_%s_v.2.0.csv", n), sep = ",", row.names = F,
append = T, col.names = F)
}
break
} else if(t == runs + 1){
ten.thousands <- ten.thousands + 1
t <- 1
}
t <- t + 1
}
}
master_data[179]
#' Simulate diffusion on network
#'
#' @param j network index (corresponds to 'Name' column in master_data)
#' @param p.infection probability of infection
#' @param pct.starting.infected percentage of nodes starting infected
#' @param n number of repetitions of diffusion
#' @return number of infection iterations for 70% of nodes infected
#' @export
#' @import data.table, igraph, dplyr
simulate.diffusion <- function(j, p.infection, pct.starting.infected, n, threshold, runs = 10000, master_data =
fread("output/undirected/master_measures_2.csv")[, c("Name", "NetworkDomain", "number_edges")]){
# load in network
file <- as.character(master_data[j, Name])
domain <- as.character(master_data[j, NetworkDomain])
edges <- master_data[j, number_edges]
el <- fread(sprintf("data/all_data/%s.csv", file))
# get number of nodes
nodes <- unique(c(el$Node1, el$Node2))
n.people <- length(nodes)
# create initial infection information
infected <- sample(
x = c(T, F),
size = n.people,
replace = T,
prob = c(pct.starting.infected, 1 - pct.starting.infected)
)
# ensure at least one node is infected
if(length(which(infected)) == 0){
infect <- sample(length(infected), size = 1)
infected[infect] <- TRUE
}
# ordering nodes
V_order <- sort(as.integer(nodes))
# create data frame of infection indices for each node
infected_data <- data.table(Nodes = V_order, infected = infected)
print(length(which(infected_data$infected))/length(infected_data$infected))
# remove some variables
rm(V_order)
ten.thousands <- 0
t <- 1
while(t < (runs+2)){
# select random edge
random.edge <- sample(nrow(el), size = 1)
el[random.edge]
c(infected_data[which(el[random.edge, Node1] == infected_data$Nodes), ],
infected_data[which(el[random.edge, Node2] == infected_data$Nodes), ])
# determine whether one of the edge's nodes are susceptible
if (infected_data[which(el[random.edge, Node1] == infected_data$Nodes), infected] !=
infected_data[which(el[random.edge, Node2] == infected_data$Nodes), infected]){
# detect susceptible node
who.susceptible <-  c(el[random.edge, Node1],el[random.edge, Node2])[!c(infected_data[el[random.edge, Node1] == infected_data$Nodes, infected],
infected_data[el[random.edge, Node2] == infected_data$Nodes, infected])]
# detect susceptible node
infected_data[who.susceptible == Nodes, infected := sample(
c(T, F),
size = 1,
prob = c(p.infection, 1 - p.infection)
)]
}
print(length(which(infected_data$infected))/length(infected_data$infected))
# save required number of iterations needed to achieve 70% of nodes infected
if(length(which(infected_data$infected))/length(infected_data$infected) >= threshold){
if(j == 1){
write.table(data.table(Name = file, Domain = domain, Nodes = n.people, Edges = edges,
Iterations_1 = (t + (ten.thousands*runs))),
file = sprintf("output/diffusion/diffusion_results_%s_v.2.02.csv", n), sep = ",", row.names = F,
col.names = T)
} else {
write.table(data.table(file, domain, n.people, edges, (t + (ten.thousands*runs))),
file = sprintf("output/diffusion/diffusion_results_%s_v.2.02.csv", n), sep = ",", row.names = F,
append = T, col.names = F)
}
break
} else if(t == runs + 1){
ten.thousands <- ten.thousands + 1
t <- 1
}
t <- t + 1
}
}
simulate.diffusion(j = 179, p.infection = 0.5, pct.starting.infected = 0.05, n = n, threshold = 0.7)
