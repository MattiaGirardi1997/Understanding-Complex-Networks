# train the model
model <- ?train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="lvq", preProcess="scale", trControl=control)
?train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="lvq", preProcess="scale", trControl=control)
getModelInfo()
# train the model
model <- ?train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="logicBag", preProcess="scale", trControl=control)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="logicBag", preProcess="scale", trControl=control)
install.packages("BiocManager", lib="/Library/Frameworks/R.framework/Versions/3.6/Resources/library")
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="logicBag", preProcess="scale", trControl=control)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.12")
# ensure the results are repeatable
set.seed(7)
# define the control using a random forest selection function
control <- rfeControl(functions=rfFuncs, method="cv", number=10)
# run the RFE algorithm
results <- rfe(master_measures_2[,6:21], master_measures_2[[22]], sizes=c(1:15), rfeControl=control)
# summarize the results
print(results)
# list the chosen features
predictors(results)
# plot the results
plot(results, type=c("g", "o"))
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="lm", preProcess="scale", trControl=control)
# prepare training scheme
control <- trainControl(method="repeatedcv", number=10, repeats=5)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="lm", preProcess="scale", trControl=control)
# estimate variable importance
importance <- varImp(model, scale=FALSE)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2, method="lm", preProcess="scale", trControl=control)
# estimate variable importance
importance <- varImp(model, scale=FALSE)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <-glm(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2)
# estimate variable importance
importance <- varImp(model, scale=FALSE)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <-glm(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2)
# estimate variable importance
importance <- varImp(model, scale=FALSE)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2, method="lm", preProcess="scale")
summary(model)
# estimate variable importance
importance <- varImp(model, scale=FALSE)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="lm", preProcess="scale")
summary(model)
# estimate variable importance
importance <- varImp(model, scale=FALSE)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="lm")
summary(model)
# estimate variable importance
importance <- varImp(model, scale=FALSE)
# summarize importance
print(importance)
# plot importance
plot(importance)
library(randomForest)
# estimate variable importance
importance <- varImp(model, scale=T)
# summarize importance
print(importance)
# plot importance
plot(importance)
# estimate variable importance
importance <- varImp(model, scale=F)
# summarize importance
print(importance)
# plot importance
plot(importance)
master_measures_2 <- fread("output/undirected/master_measures_2.csv")
master_measures_2 <- na.omit(master_measures_2)
#### transform Social,Offline and Social,Online into logical variables
for(i in 1:length(master_measures_2$ID)){
if(master_measures_2[i, NetworkDomain] %in% c("Social,Offline", "Social,Online")){
master_measures_2[i, "NetworkDomain"] <- gsub(".*", "1", master_measures_2[i, "NetworkDomain"])
} else {
master_measures_2[i, "NetworkDomain"] <- gsub(".*", "0", master_measures_2[i, "NetworkDomain"])
}
}
master_measures_2$NetworkDomain <- as.factor(master_measures_2$NetworkDomain)
# prepare training scheme
control <- trainControl(method="repeatedcv", number=10, repeats=5)
# train the model
model <- train(NetworkDomain ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="lvq", preProcess="scale", trControl=control)
# estimate variable importance
importance <- varImp(model, scale=FALSE)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="icr")
results <- fread("output/diffusion/consolidated/results_1.csv")[, Mean]
master_measures_2 <- data.table(fread("output/undirected/master_measures_2.csv"), Mean = results)
master_measures_2 <- na.omit(master_measures_2)
# prepare training scheme
control <- trainControl(method="repeatedcv", number=10, repeats=5)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="icr")
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="icr")
summary(model)
# estimate variable importance
importance <- varImp(model, scale=F)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2, method="icr")
summary(model)
# estimate variable importance
importance <- varImp(model, scale=F)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2, method="lm")
# estimate variable importance
importance <- varImp(model, scale=F)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2, method="Bstlm")
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2, method="BstLm")
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2, method="BstLm")
# estimate variable importance
importance <- varImp(model, scale=F)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="BstLm")
# estimate variable importance
importance <- varImp(model, scale=F)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="glm")
summary(model)
# estimate variable importance
importance <- varImp(model, scale=F)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="lm")
# estimate variable importance
importance <- varImp(model, scale=F)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="glmboost")
# train the model
model <- train(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="glmboost")
# estimate variable importance
importance <- varImp(model, scale=F)
# summarize importance
print(importance)
# plot importance
plot(importance)
#### transform Social,Offline and Social,Online into logical variables
for(i in 1:length(master_measures_2$ID)){
if(master_measures_2[i, NetworkDomain] %in% c("Social,Offline", "Social,Online")){
master_measures_2[i, "NetworkDomain"] <- gsub(".*", "1", master_measures_2[i, "NetworkDomain"])
} else {
master_measures_2[i, "NetworkDomain"] <- gsub(".*", "0", master_measures_2[i, "NetworkDomain"])
}
}
master_measures_2$NetworkDomain <- as.factor(master_measures_2$NetworkDomain)
master_measures_2 <- na.omit(master_measures_2)
# prepare training scheme
control <- trainControl(method="repeatedcv", number=10, repeats=5)
# train the model
model <- train(NetworkDomain ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="logitboost", preProcess="scale", trControl=control)
# train the model
model <- train(NetworkDomain ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="LogitBoost", preProcess="scale", trControl=control)
# estimate variable importance
importance <- varImp(model, scale=FALSE)
# summarize importance
print(importance)
# plot importance
plot(importance)
# train the model
model <- train(NetworkDomain ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2, method="lvq", preProcess="scale", trControl=control)
# estimate variable importance
importance <- varImp(model, scale=FALSE)
# summarize importance
print(importance)
# plot importance
plot(importance)
# define the control using a random forest selection function
control <- rfeControl(functions=rfFuncs, method="cv", number=10)
# run the RFE algorithm
results <- rfe(master_measures_2[,6:21], master_measures_2[[22]], sizes=c(1:15), rfeControl=control)
# summarize the results
print(results)
# list the chosen features
predictors(results)
# plot the results
plot(results, type=c("g", "o"))
# ensure the results are repeatable
set.seed(7)
# define the control using a random forest selection function
control <- rfeControl(functions=rfFuncs, method="cv", number=10)
# run the RFE algorithm
results <- rfe(master_measures_2[,6:21], master_measures_2[[3]], sizes=c(1:15), rfeControl=control)
# summarize the results
print(results)
# list the chosen features
predictors(results)
# plot the results
plot(results, type=c("g", "o"))
?rfecontrol
?rfeControl
# define the control using a random forest selection function
control <- rfeControl(functions=rfFuncs, method="boot", number=10)
# run the RFE algorithm
results <- rfe(master_measures_2[,6:21], master_measures_2[[22]], sizes=c(1:15), rfeControl=control)
# summarize the results
print(results)
# list the chosen features
predictors(results)
# plot the results
plot(results, type=c("g", "o"))
model <- lm(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity,
data=master_measures_2)
summary(model)
vif(model)
car::vif(model)
model <- lm(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2)
summary(model)
car::vif(model)
model <- glm(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2)
summary(model)
model <- lm(Mean ~ AverageComplexity + AverageDegree + AveragePathLength +
AverageTransitivity + BetweennessCentrality + Closeness + ClosenessCentrality +
Complexity + DegreeAssortativity + DegreeCentrality + DegreeDistribution +
Density + EigenvectorCentrality + EigenvectorCentrality_2 + Entropy +
GlobalTransitivity + Nodes + Edges,
data=master_measures_2)
summary(model)
car::vif(model)
# calculate correlation matrix
correlationMatrix <- cor(master_measures_2[,4:21])
# summarize the correlation matrix
print(correlationMatrix)
# find attributes that are highly corrected (ideally >0.75)
highlyCorrelated <- findCorrelation(correlationMatrix, cutoff = 0.75)
# print indexes of highly correlated attributes
names(master_measures_2[,4:21])[print(highlyCorrelated)]
car::vif(model)
# find attributes that are highly corrected (ideally >0.75)
highlyCorrelated <- findCorrelation(correlationMatrix, cutoff = 0.5)
# print indexes of highly correlated attributes
names(master_measures_2[,4:21])[print(highlyCorrelated)]
car::vif(model)
results <- fread("output/diffusion/consolidated/results_1.csv")[, Mean]
master_measures_2 <- data.table(fread("output/undirected/master_measures_2.csv"), Mean = results)
master_measures_2 <- na.omit(master_measures_2)
master <- na.omit(master_measures_2)
ggplot(master, aes(x = AverageDegree, y = Mean)) + geom_line()
ggplot(master, aes(x = AverageDegree, y = Mean)) + geom_point()
ggplot(master, aes(x = AverageDegree, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master[AverageDegree < 500], aes(x = AverageDegree, y = Mean, color = NetworkDomain)) + geom_point()
View(master_measures_2)
names <- names(master)
names
ggplot(master, aes(x = names[4], y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = eval(parse(names[4])), y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = parse(names[4]), y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = names[4], y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = names[5], y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = master[, names[4]], y = Mean, color = NetworkDomain)) + geom_point()
names(master)
ggplot(master, aes(x = Edges, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = Nodes, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = AverageComplexity, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = AverageComplexity, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = Nodes, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = AverageComplexity, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = AverageDegree, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = AveragePathLength, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = AverageTransitivity, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = BetweennessCentrality, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = Closeness, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = ClosenessCentrality, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = Closeness, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = ClosenessCentrality, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = Complexity, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = DegreeAssortativity, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = DegreeCentrality, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = DegreeDistribution, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = Density, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = EigenvectorCentrality, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = EogenvectorCentrality_2, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = iogenvectorCentrality_2, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = EigenvectorCentrality_2, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = EigenvectorCentrality, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = EigenvectorCentrality_2, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = Entropy, y = Mean, color = NetworkDomain)) + geom_point()
ggplot(master, aes(x = GlobalTransitivity, y = Mean, color = NetworkDomain)) + geom_point()
accuracy <- seq(1:100)
accuracy <- 1:100
